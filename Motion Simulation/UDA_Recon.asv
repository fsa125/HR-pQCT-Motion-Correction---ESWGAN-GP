% -----------------------------------------------------------------------
% This file is part of the ASTRA Toolbox
% 
% Copyright: 2010-2022, imec Vision Lab, University of Antwerp
%            2014-2022, CWI, Amsterdam
% License: Open Source under GPLv3
% Contact: astra@astra-toolbox.com
% Website: http://www.astra-toolbox.com/
% -----------------------------------------------------------------------

%%This is the code for introducing synthetic physics-based motion
%%

function recon_2d = UDA_Recon(P,output_filename)
%Start from here!

%P -----------------------> image
% in-plane rotation angles
values = [pi/100, pi/120, -pi/60, -pi/40, -pi/20, pi/60, pi/50, pi/10, -pi/80];

numRandomValues = 1;  % You can change this to the desired number

% Generate random indices to select values from the list
randomIndices = randi(numel(values), 1, numRandomValues);

% Extract random values from the list using the indices
randomValues = values(randomIndices);


P = double (P);
P = imresize(P,[1024,1024]); %Resize it to [1024 1024]

angles = linspace2(-pi/4, 7*pi/4, 1800); %sinogram angles/spacing, 
%angles_cor = calculate_theta_prime (angles);
angles_cor1 = angles + randomValues;
%angles2 = linspace2(-pi/4, 7*pi/4, 900);
%angles = linspace2(0, 2*pi, 900);
%proj_geom = astra_create_proj_geom('parallel3d', 1.0, 1.0, 400, 400, angles);
%proj_geom_og = astra_create_proj_geom('parallel3d', 1.0, 1.0, 400, 400, angles);

%proj_geom = astra_create_proj_geom('fanflat', 1.0, 400, angles, 401, 205);
vol_geom = astra_create_vol_geom(1024, 1024); %Previously 512 512
proj_geom = astra_create_proj_geom('parallel', 1.0, 1024, angles);

vol_geom3 = astra_create_vol_geom(1024,1024); %previosuly 512 512
proj_geom3 = astra_create_proj_geom('parallel', 1.0, 1024, angles_cor1); %Number of detectors increase with higher pixels
%%
% As before, create a sinogram from a phantom
%P = phantom(256);
%%Introducing a rotation
%P_1 = imrotate( P , 12 );
%P_1 = imresize(P_1,[256,256]);
%figure(1); imshow(P_1, []);
%%
[sinogram_id, sinogram] = astra_create_sino_gpu(P, proj_geom, vol_geom);
%[sinogram_id_og, sinogram_og] = astra_create_sino_gpu(P, proj_geom2, vol_geom2);
[sinogram_id_og1, sinogram_og1] = astra_create_sino_gpu(P, proj_geom3, vol_geom3);
%figure(1); imshow(P, []);
%sinogram = motionBlur(sinogram, 15);
%sinogram_og = translateImage(sinogram_og,3);
%figure(2); imshow(sinogram, []);
%figure(3); imshow(sinogram_og, []);
%sinogram (200:300,:) = sinogram_og (200:300,:);
%figure(3); imshow(sinogram_og1, []);
%%
A =  randi([1, 1600]);
%B = randi([1, 900],1,800);
B = A + 200; %200
%for i =200 1:length(A)
%sinogram (A(i), :) = (1/sqrt(3)* cos (pi/6)*cos (pi/6))*sinogram_og(B(i),:);
%end
%for i = 300:320
%sinogram (i, :) = sinogram_og (i,:);
%end
for i = A:B
sinogram (i, :) = sinogram_og1 (i,:);
end

%for i = 1:length(B)
%sinogram (B(i), :) = 0;
%end
%sinogram (200, :) = sinogram_og(700,:);

%sinogram (300, :) = sinogram_og(800,:);

%sinogram(700,:) = sinogram_og(1200,:);

%sinogram(800,:) = sinogram_og(1400,:);
%figure(5); imshow(sinogram, []);
%%
%% Difference image
%diff_sinogram = sinogram - sinogram_og;
%Threshold = 700;
%figure(4); imshow(edge(diff_sinogram,'Canny'), []);
%ones_sinogram = ones (900,500);
%Edge_sino = edge(diff_sinogram,'sobel',Threshold);
%figure(5); imshow(Edge_sino, []);
%ones_sinogram (100:400,:) = sinogram_og (100:400,:) .*Edge_sino (100:400,:) ;
%%%ones_sinogram = sinogram_og  .*Edge_sino  ;
%ones_sinogram = ones_sinogram/max(ones_sinogram(:));
%%figure(6); imshow(ones_sinogram, []);

%Take the different image, make a ones matrix to separate different portion
%from the sinogram

%%
% Motion Blur of the separated sinogram
%H = fspecial('motion',2,0);
%MotionBlur = imfilter(ones_sinogram,H,'replicate');
%MotionBlur = Comet (ones_sinogram,90,10);
%figure (6),imshow(MotionBlur);

%%sum the separated motion blur image.

%sinogram   = sinogram + MotionBlur ;
%sinogram = sinogram / max(sinogram (:));

%figure(7); imshow(sinogram , []);
%%
astra_mex_data2d('delete', sinogram_id);

% We now re-create the sinogram data object as we would do when loading
% an external sinogram
sinogram_id = astra_mex_data2d('create', '-sino', proj_geom, sinogram);

% Create a data object for the reconstruction
rec_id = astra_mex_data2d('create', '-vol', vol_geom);

% Set up the parameters for a reconstruction algorithm using the GPU
cfg = astra_struct('SIRT_CUDA');
cfg.ReconstructionDataId = rec_id;
cfg.ProjectionDataId = sinogram_id;

% Available algorithms:
% SIRT_CUDA, SART_CUDA, EM_CUDA, FBP_CUDA (see the FBP sample)


% Create the algorithm object from the configuration structure
alg_id = astra_mex_algorithm('create', cfg);

% Run 150 iterations of the algorithm
astra_mex_algorithm('iterate', alg_id, 500);

% Get the result
rec = astra_mex_data2d('get', rec_id);
%figure(8); imshow(rec, []);
%figure(9); imshow(abs(rec-P) , []);
rec = uint8(rec);
imwrite(rec, output_filename);
% Clean up. Note that GPU memory is tied up in the algorithm object,
% and main RAM in the data objects.
astra_mex_algorithm('delete', alg_id);
astra_mex_data2d('delete', rec_id);
astra_mex_data2d('delete', sinogram_id);
end